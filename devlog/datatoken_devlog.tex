%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University Assignment Title Page 
% LaTeX Template
% Version 1.0 (27/12/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (http://en.wikibooks.org/wiki/LaTeX/Title_Creation)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
% Instructions for using this template:
% This title page is capable of being compiled as is. This is not useful for 
% including it in another document. To do this, you have two options: 
%
% 1) Copy/paste everything between \begin{document} and \end{document} 
% starting at \begin{titlepage} and paste this into another LaTeX file where you 
% want your title page.
% OR
% 2) Remove everything outside the \begin{titlepage} and \end{titlepage} and 
% move this file to the same directory as the LaTeX file you wish to add it to. 
% Then add \input{./title_page_1.tex} to your LaTeX file where you want your
% title page.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\title{Title page with logo}
%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fullpage}
%\usepackage{harvard}

\begin{document}


\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page
 
%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\LARGE XJTLU}\\[1.5cm] % Name of your university/college
\textsc{\Large DataToken Developer Diary}\\[0.5cm] % Major heading such as course name
\textsc{\large Solidity Smart Contract}\\[0.5cm] % Minor heading such as course title

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries P2P Cellular Data Sharing}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]
 
%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Author:}\\
Zhuoqun \textsc{Liu} % Your name
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Supervisor:} \\
Dr. Siyi \textsc{Wang} % Supervisor's Name
\end{flushright}
\end{minipage}\\[2cm]

% If you don't want a supervisor, uncomment the two lines below and remove the section above
%\Large \emph{Author:}\\
%John \textsc{Smith}\\[3cm] % Your name

%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[1.5cm] % Date, change the \today to a set date if you want to be precise

%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics[width=0.33\linewidth]{XJTLU_shield.eps}\\[0.3cm] % Include a department/university logo - this will require the graphicx package
 
%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}
\tableofcontents

\begin{abstract}
This project aims to implement a blockchain oriented cellular 
data sharing software on Ethereum platform. The first part of this
Final Year Project focuses on software layer implementation, and the
second half will consider some potential implementations in real life.

\end{abstract}

\section{Introduction}
DataToken is the name of the smart contract to be developed as my Final Year Project (FYP) in XJTLU.
All DataToken projects will be named with postfix``alpha'' since the propotype development is far from 
finished yet.
Versions are depicted in *.* format e.g. 0.0; increment on the number before the dot means 
new functions or features are added, increment on the number after the dot means minor 
changes are added to source code.

\section{DataToken Alpha 0.0}
version alpha 0.0 
initially designed functions
createAccount, askforSharing

\section{DataToken Alpha 0.1 20171014 Fri}
The contract should be an ether pool (etherbase)
thus it should allow user charge their account by putting ether in to the contranct.
the first method to put ether in is the provide value when creating a user account.
A second way is to call topUp function to send ether to this contract and get some token.
By design, the token distributed by the contract should be at a constant exchange rate to ether.
currently, the rate is set to be 1 token = 1 wei which is the smallest ether unit.

A withdraw function is created corresponding to topUp function.
This function should allow user account to exchange their token back to ether in their ether address.
But the chellange is, when sending ether from the contract, the gas fee is to be paid by the sender, if the sender here is the message sender i.e. the user,
the user will pay for the gas, however, if the sender is considered as the contract itself, there will be a problem.
If the contract is charged gas for each transaction (the contract will loss at least 0.001 ether for each transaction according to current gas price),
the contract etherbase will fail due to too many withdraw transactions. The contract itself is not making any profit but will have to pay some fee due to users' transaction,
that's not fair.
Then an experiment should be held to examine how the ethereum network perform such a transaction from the contract with msg.sender a user to be the caller of the function.
$0.001$ ether = $10^15$  wei which is a large amount of loss in terms of wei.
    experiment design:
    create the contract with external address A;
    create user account with external address B, charge 0.01 ether for token;
        expecting: the contract has 0.01 ether and address B pay 0.01 ether plus gas fee;
    address B call withdraw function to withdraw 0.01 ether;
        expecting: the contract send 0.01 ether to B and B pay the gas, resulting B receive 0.01 minus gas fee.
    An easy way to examine the behavior of the function (actually the contract convention) is to set a getter for the contract.
    top-up the contract first, suppose the contract possesses \_amountA wei
        check the contract balance;
    withdraw \_amountB wei by calling function withdraw as external address (user)
        check the contract balance;
        if the balance == \_amountA - \_amountB
            the transaction fee was paid by the msg.sender i.e. the user account.
        else
            the fee was paid by the contract

    If by convention the user will pay for calling a function that send ether from contract etherbase, 
    the withdraw function need not to have a mechanism to make the ether in contract intact
    
The contract shouldn't be paying that fee for transfering back. 



\subsection{Diary 20171016 Mon}
Mapping a host address to a guest address will make the link unique, thereby the sevice can only be recorded one on one which is no good for practical use.
I'm now searching for a datastructurea like array which can be marked as related to one host address so that all guests of the same host address can be stored in it.
In the documentation of solidity \^0.4.18, mapping types expression $$mapping(KeyType => ValueType)$$
allows KeyType to be almost any type except for mapping type; ValueType to any type including mapping type.
This mapping feature can merge mappings from guest to payment status.
And here is a solution for linking host to guest.\href{https://ethereum.stackexchange.com/questions/27053/how-to-create-a-mapping-of-string-and-struct-array-in-solidity}{The following code is a good demonstration from stackexchange.}
\begin{lstlisting}
    pragma solidity ^0.4.11;
    
    contract AuthorizationManager{
        struct User{
          string userId;
          uint roleId;
        }
    
        mapping (string => User[]) companyUserMap;
    
        function addUser(string _key,string _userId, uint _roleId){
            companyUserMap[_key].push(User(_userId,_roleId));
        }
    
        function removeSingleUser(string _key){
            companyUserMap[_key].length--;
        }
    }
\end{lstlisting}
\subsection{Diary 20171017 Tue}
How should a ledger be like?
An individual ledger or a public ledger to record everyone?
\section{DataToken Alpha 0.2 20171110}
Contract vatiable list:
\begin{itemize}
    \item uint256 public userIndex //index of userInfo array Info
    \item mapping (address$=>$bool) public isNotNew //used or not mark
    \item mapping (address$=>$uint256) public index //to query in array Info
    
    
\end{itemize}
With the structure described in version 0.1, the dataToken v0.2
is designed as objective oriented and mapping feature of solidity language
is used to distinguish different state of users. This time, each 
private ethereum address is treated as a usable user account, user name
and user Id. The contract will create an array of users but rather a map 
array of users, although a ethereum address is marked as used by a map.\\
The first feature of this contract is to hold user information. Then 
the contract need to have functions to add new user and delete user as
a ethereum user's wish.

\subsection{Diary 20171111 Sat}
Behavior test of version 0.2: addUser()
expecting when calling this function with an ethereum address, 
the function:
\begin{enumerate}
    \item initializes a userInfo element in a userInfo array.
    \item mark the message sender as used address by mapping the address
    to bool value true (used), which by default is false (unused).
    \item index increment is needed since the function add userInfo
    to the same userInfo array each time and the index should be different.
    \item store the index of current userInfo by mapping the address to 
    a uint256 value.\\\\
\end{enumerate}
Method addUser() is described by the following code:
\begin{lstlisting}
    function addUser() isNew public {
        
        Info.push(userInfo(msg.sender,false,0));
        isNotNew[msg.sender]=true;
        index[msg.sender]=userIndx;
        userIndx+=1;
    }
\end{lstlisting}
\noindent
\textbf{Bug:}
\begin{enumerate}
    \item \textbf{Default target value (uint256) in a map is 0}\\
    An used address will have the userIndex mapping value 0, which 
    will be interpreted as position [0] if Info[0] does hold information
    of a user.\\
    \textbf{Trail Fix 1:} Initialize userIndex with none zero value, say 1.
    Position [0] in Info array is initialized with the contract address
    and other default values.\\
\end{enumerate}
\textbf{Limitations:}
\begin{enumerate}
    \item Information of users is stored by an array 
    but the array may be size limited.\\
    \textbf{Answer:} array is capable to store a very big number of 
    indices like $2^{256}$; it maybe not a problem for the scope of a
    small application on Ethereum. This user information system cound 
    be altered by some more flexible methods in solidity language.
    \item  A method inside dataToken contract named removeUser() will 
    remove message sender from user list and redeem Ethers according
    to token balance.
    Once a user (address) is removed from Info[] array,
    the position (index) of it 
    will be empty, however, current addUser function won't be able
    to reuse the released indices.\\
    \textbf{Answer:} For this version of implementation (alpha V0.2), the removed
    positions will be left empty and not be used by the contract. 
   
\end{enumerate}
\subsection{Diary 20171114 Tue}
\textbf{Design of removeUser() method.}
The very first question is what have been created
by a call of addUser(). As the definition of addUser() in Diary 20171111 Sat,
once addUser() is called:
\begin{itemize}
    \item Info[] will have a new userInfo cascated at the end of it. 
    \item A corresponding position in map \textbf{index} is created to hold 
    the index of that userInfo.
    \item A nother map \textbf{isNotNew} will hold the state of whether an
    addresss is used or not. Being True means this address is not a new user.
    \\
\end{itemize}
Once call of removeUser() will remove the created information above.
\begin{itemize}
    \item Mark the isNotNew mapping of the address as false.
    The information of this address won't be removed from \textbf{Info}.
    The corresponding index will be reserved.
    \item Once this address is marking itself as a user again,
    addUser() could check whether it's \textbf{index} mapping
    is non-zero, then the old position of this address can be marked as
    user by just changing the value of \textbf{isNotNew} mapping.
    \\
\end{itemize}
\textbf{Limitations}
\begin{enumerate}
    \item This will also cause another problem that a user must be aware
    that the token won't be redeemed if withdraw function is not called.
\end{enumerate}
Behavior of this function is as expected so far.


%\bibliographystyle{agsm}
\bibliographystyle{IEEEtran}
\bibliography{reference}
\end{document}