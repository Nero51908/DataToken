%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}





\title{DataTokenAlpha Documentation}
\date{Mar 20, 2018}
\release{}
\author{Zhuoqun Liu}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


This is the documentation of DataTokenAlpha.

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.5]{{logo}.png}\hspace*{\fill}}


\chapter{Introduction}
\label{\detokenize{index:introduction}}\label{\detokenize{index:welcome-to-datatokenalpha}}
This project aims to develop a scheme for peer-to-peer (P2P) cellular data sharing and to
construct a prototype Ethereum smart contract with respect to the scheme using Solidity which is
a blockchain oriented programming language. Smart contract DataToken-Alpha (latest version 0.3.2)
as the scheme implementation has been under development. Hence, DataToken, a token of Ether
(Intrinsic Cryptocurrency of Ethereum) is created for data service transfer recording.The uniqueness
of such implementation is that all the information held by the contract is protected by Ethereum
network based on blockchain technology from computational hacking.

The implementation is started from analyzing behaviors that a ledger system is expected to have.
By design, the contract is firstly able to offer and manage token like a bank in real world
and secondly, it is capable to work as a cellular data service trade centre where users of such
contract are able to transfer Internet access in terms of cellular data usage and token.
Solidity code thud is used to implement necessary features with respect to the behaviors mentioned above.
Finally, a prototype of DataToken-Alpha for autonomous data trading is ready for further polish
in the next semester when this project will focus on upgrading DataToken-Alpha to be a practically
deployable smart contract as close as possible.


\chapter{Terms}
\label{\detokenize{index:terms}}
In the context of DataTokenAlpha contract, each Ethereum address
has three possible roles:
\begin{itemize}
\item {} 
Receiver (Default role)

\item {} 
Provider (A receiver can switch user role as provider)

\item {} 
Paired (A receiver who is using AP service of a provider)

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Both “receiver” and “paired” are referred to as “receiver” in the following documentation. User {\hyperref[\detokenize{index:identification}]{\sphinxcrossref{identification}}} value will distinguish paired receiver from unpaired receiver.
\end{sphinxadmonition}


\chapter{Coding Style}
\label{\detokenize{index:coding-style}}
Camel case names for variable and function names.
Internal functions all start with an underscore \_.
Input parameter of functions starts with an underscore \_.


\chapter{Contract Variables}
\label{\detokenize{index:contract-variables}}
\begin{sphinxadmonition}{note}{Note:}
Contracts variables are declared at the beginning of solidity contract body.
In this section, variable types and availability are indicated by source code definition
below each mentioned variables.
\end{sphinxadmonition}


\section{owner}
\label{\detokenize{index:owner}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{address} \PYG{n+nx}{owner}\PYG{p}{;}
\end{sphinxVerbatim}

The message sender address of the transaction that has initiated this
DataTokenAlpha contract is stored in this variable.

All initial supply tokens are assigned to this address.
That is, all usable tokens are sold buy owner address.


\section{tokenName}
\label{\detokenize{index:tokenname}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{string} \PYG{k+kr}{public} \PYG{n+nx}{tokenName} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}dataToken\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

The name of token defined by this contract is dataToken.


\section{decimals}
\label{\detokenize{index:decimals}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{uint} \PYG{k+kr}{public} \PYG{n+nx}{decimals} \PYG{o}{=} \PYG{l+m+mi}{9}\PYG{p}{;}
\end{sphinxVerbatim}

This token will support 9 digits after decimal point.
The number of 9 actually defines the smallest operable unit of each token.


\section{initialSupply}
\label{\detokenize{index:initialsupply}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{uint256} \PYG{n+nx}{initialSupply} \PYG{o}{=} \PYG{l+m+mi}{666}\PYG{p}{;}
\end{sphinxVerbatim}

There will be 666 usable tokens in this contract.


\section{totalSupply}
\label{\detokenize{index:totalsupply}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{uint256} \PYG{n+nx}{totalSupply} \PYG{o}{=} \PYG{n+nx}{initialSupply} \PYG{o}{*} \PYG{l+m+mi}{10} \PYG{o}{*}\PYG{o}{*} \PYG{n+nx}{decimals}\PYG{p}{;}
\end{sphinxVerbatim}

Number of tokens in terms of the smallest unit
is 666,000,000,000.

\begin{sphinxadmonition}{note}{Note:}
The smallest unit is DataToken. There are 666,000,000,000 DataTokens supplied by this contract.
\end{sphinxadmonition}


\section{APID\_counter}
\label{\detokenize{index:apid-counter}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{uint256} \PYG{n+nx}{APID\PYGZus{}counter} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}

This number will be assigned to a newly registered provider.

If a successful call of {\hyperref[\detokenize{index:surprovider}]{\sphinxcrossref{surProvider}}} is initiated by
a user without {\hyperref[\detokenize{index:apid}]{\sphinxcrossref{APID}}} value,
APID\_counter will be assigned to the new provider’s {\hyperref[\detokenize{index:apid}]{\sphinxcrossref{APID}}} mapping,
and the value of APID\_counter will be updated by +1 as {\hyperref[\detokenize{index:surprovider}]{\sphinxcrossref{surProvider}}} implemented.


\section{role}
\label{\detokenize{index:role}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{enum} \PYG{n+nx}{role} \PYG{p}{\PYGZob{}}\PYG{n+nx}{ISRECEIVER}\PYG{p}{,} \PYG{n+nx}{ISPROVIDER}\PYG{p}{,} \PYG{n+nx}{PAIRED}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This variable defines three possible roles of contract users.

Numerically, identification has values:
\begin{itemize}
\item {} 
role.ISRECEIVER = 0

\item {} 
role.ISPROVIDER = 1

\item {} 
role.PAIRED = 2

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
The following variables are of mapping type.

\sphinxhref{http://solidity.readthedocs.io/en/develop/types.html?\#mappings}{Click to find mapping in solidity documentation}
\end{sphinxadmonition}


\section{identification}
\label{\detokenize{index:identification}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{mapping} \PYG{p}{(}\PYG{n+nx}{address} \PYG{p}{=\PYGZgt{}} \PYG{n+nx}{role}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{identification}\PYG{p}{;}
\end{sphinxVerbatim}

This mapping takes Ethereum address as key and role (enum type) as the mapped value.

By default, any unassigned value is recognized as 0, therefore,
Ethereum addresses automatically have \sphinxstyleemphasis{role.ISRECEIVER} (numerical value is 0) as mapping values of {\hyperref[\detokenize{index:identification}]{\sphinxcrossref{identification}}}.

When a receiver address calls function {\hyperref[\detokenize{index:surprovider}]{\sphinxcrossref{surProvider}}},
\sphinxstyleemphasis{identification} mapping value of this address will be changed to \sphinxstyleemphasis{role.ISPROVIDER} (numerical value is 1).

When a receiver address has called function {\hyperref[\detokenize{index:link}]{\sphinxcrossref{link}}} successfully,
mapping value of the address will be designated as \sphinxstyleemphasis{role.PAIRED} (numerical value is 2).


\section{APID}
\label{\detokenize{index:apid}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{mapping} \PYG{p}{(}\PYG{n+nx}{address} \PYG{p}{=\PYGZgt{}} \PYG{n+nx}{uint256}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{APID}\PYG{p}{;}
\end{sphinxVerbatim}

This mapping shows numerical ID of a provider address.

When a provider is deploying Wi-Fi AP, frontend client could
query value of this mapping with the Ethereum address
of the provider. Then the unique numerical ID can be shown in SSID.

There are two reasons for this mapping:
\begin{itemize}
\item {} 
SSID has String length limit. A full length Ethereum address exceeds such limitation, however, a truncated address is not easy to resolve.

\item {} 
Ethereum address behind a wireless AP could be protected by this APID. Currently, {\hyperref[\detokenize{index:providerbehind}]{\sphinxcrossref{providerBehind}}} is publicly declared, but it’s high availability is not necessary.

\end{itemize}


\section{balance}
\label{\detokenize{index:balance}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{mapping} \PYG{p}{(}\PYG{n+nx}{address} \PYG{p}{=\PYGZgt{}} \PYG{n+nx}{uint256}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{balance}\PYG{p}{;}
\end{sphinxVerbatim}

Mapping balance uses Ethereum address as key and number of tokens as value.

Token balance of each contract user can be viewed by calling this mapping.

Only one internal function {\hyperref[\detokenize{index:id1}]{\sphinxcrossref{\_transfer}}} can manipulate values of this mapping without restriction.


\section{providerBehind}
\label{\detokenize{index:providerbehind}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{mapping} \PYG{p}{(}\PYG{n+nx}{uint256} \PYG{p}{=\PYGZgt{}} \PYG{n+nx}{address}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{providerBehind}\PYG{p}{;}
\end{sphinxVerbatim}

This mapping is a conversed version of {\hyperref[\detokenize{index:apid}]{\sphinxcrossref{APID}}} mapping.

APID of an account is a key of this mapping.
The value corresponds to the key (APID grabbed from SSID)
is the Ethereum address of the AP host.


\section{numberOfUsers}
\label{\detokenize{index:numberofusers}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{mapping} \PYG{p}{(}\PYG{n+nx}{address} \PYG{p}{=\PYGZgt{}} \PYG{n+nx}{uint}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{numberOfUsers}\PYG{p}{;}
\end{sphinxVerbatim}

For each contract user of provider role, this mapping is important.
\begin{itemize}
\item {} 
When a receiver is linked to a provider by {\hyperref[\detokenize{index:link}]{\sphinxcrossref{link}}} function, mapping value of the provider should be added by 1.

\item {} 
When the receiver has successfully called function {\hyperref[\detokenize{index:payandleave}]{\sphinxcrossref{payAndLeave}}}, the value of numberOfUsers should be decreased by 1.

\item {} 
Only when this mapping value is 0 which is the default value, can a provider call function {\hyperref[\detokenize{index:surreceiver}]{\sphinxcrossref{surReceiver}}} to switch user role back to \sphinxstyleemphasis{role.ISRECEIVER}.

\end{itemize}


\section{providerOf}
\label{\detokenize{index:providerof}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{mapping} \PYG{p}{(}\PYG{n+nx}{address} \PYG{p}{=\PYGZgt{}} \PYG{n+nx}{address}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{providerOf}\PYG{p}{;}
\end{sphinxVerbatim}

For each user of \sphinxstyleemphasis{role.PAIRED} who was of \sphinxstyleemphasis{role.ISRECEIVER} before a successful call of {\hyperref[\detokenize{index:link}]{\sphinxcrossref{link}}} function,
this mapping will be assigned by the Ethereum address of the linked provider.

Only users being served has nonzero providerOf mapping.
Value of this mapping will be reset to 0 after a successful call of {\hyperref[\detokenize{index:payandleave}]{\sphinxcrossref{payAndLeave}}}.


\section{priceOf}
\label{\detokenize{index:priceof}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{mapping} \PYG{p}{(}\PYG{n+nx}{address} \PYG{p}{=\PYGZgt{}} \PYG{n+nx}{uint256}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{priceOf}\PYG{p}{;}
\end{sphinxVerbatim}

When a receiver intends to switch user role to be a provider,
function {\hyperref[\detokenize{index:surprovider}]{\sphinxcrossref{surProvider}}} will request a input that specifies pricing of this AP service to deploy in DataToken/MB.


\section{usageOf}
\label{\detokenize{index:usageof}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{mapping} \PYG{p}{(}\PYG{n+nx}{address} \PYG{p}{=\PYGZgt{}} \PYG{n+nx}{mapping} \PYG{p}{(}\PYG{n+nx}{address} \PYG{p}{=\PYGZgt{}} \PYG{n+nx}{uint256}\PYG{p}{)}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{usageOf}\PYG{p}{;}
\end{sphinxVerbatim}

This is a mapping designed to verify data usage information to prevent cheating on both sides when issuing payment.

A function {\hyperref[\detokenize{index:tolerance}]{\sphinxcrossref{\_tolerance}}} is defined to check whether data usage record can reach a consensus.

If records from both provider and receiver agree with each other, the receiver will pay for the amount of data usage specified by the provider.

\begin{sphinxadmonition}{warning}{Warning:}
What will happen if a consensus is not reached has not been defined yet!
\end{sphinxadmonition}


\section{passwd}
\label{\detokenize{index:passwd}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{mapping} \PYG{p}{(}\PYG{n+nx}{address} \PYG{p}{=\PYGZgt{}} \PYG{n+nx}{string}\PYG{p}{)} \PYG{n+nx}{internal} \PYG{n+nx}{passwd}\PYG{p}{;}
\end{sphinxVerbatim}

This mapping is where provider can store their designated key to generate dynamic PIN for wireless AP authentication.

User will be require to input a password when function {\hyperref[\detokenize{index:surprovider}]{\sphinxcrossref{surProvider}}} is called.


\chapter{Event}
\label{\detokenize{index:event}}
\begin{sphinxadmonition}{note}{Note:}
Event is used as log when important information of the contract is changed, for example, user balance changed as a result of transfer.
\end{sphinxadmonition}


\section{Transfer}
\label{\detokenize{index:transfer}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{event} \PYG{n+nx}{Transfer}\PYG{p}{(}\PYG{n+nx}{address} \PYG{n+nx}{\PYGZus{}from}\PYG{p}{,} \PYG{n+nx}{address} \PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{n+nx}{uint256} \PYG{n+nx}{value}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Adding this event to the end of a function that issues token transfers will trigger a return message about the transfer.


\section{sur}
\label{\detokenize{index:sur}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{event} \PYG{n+nx}{Sur}\PYG{p}{(}\PYG{n+nx}{address} \PYG{n+nx}{\PYGZus{}user}\PYG{p}{,} \PYG{n+nx}{role} \PYG{n+nx}{\PYGZus{}newrole}\PYG{p}{,} \PYG{n+nx}{bool} \PYG{n+nx}{success}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

When a user switch user role, this event will return a message indicating the original user role, the intended user role and whether the operation has succeeded.


\chapter{Internal Functions}
\label{\detokenize{index:internal-functions}}
\begin{sphinxadmonition}{note}{Note:}
Internal functions are invisible to Web3 Javascript API and external calls from other contracts.
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
Internal functions are defined with great power that can easily change data on Ethereum like DataToken balance of contract users.
\end{sphinxadmonition}


\section{\_transfer}
\label{\detokenize{index:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{\PYGZus{}transfer}\PYG{p}{(}\PYG{n+nx}{address} \PYG{n+nx}{\PYGZus{}from}\PYG{p}{,} \PYG{n+nx}{address} \PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{n+nx}{uint256} \PYG{n+nx}{\PYGZus{}value}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
This function has great power that it can manipulate balance between addresses without any restriction.
\end{sphinxadmonition}

A call of this function is able to transfer \_value amount of token
from Ethereum address \_from to address \_to. The function has the
highest authority in a transfer operation.

It is defined as internal
for safety concern that API (web3 implemented by ethereum core team)
cannot call this function directly.

\begin{sphinxadmonition}{tip}{Tip:}
This function is the core of functions that are able to cause change of DataToken balance.
\end{sphinxadmonition}


\section{\_sur}
\label{\detokenize{index:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{\PYGZus{}sur}\PYG{p}{(}\PYG{n+nx}{address} \PYG{n+nx}{\PYGZus{}user}\PYG{p}{,} \PYG{n+nx}{role} \PYG{n+nx}{\PYGZus{}oldrole}\PYG{p}{,} \PYG{n+nx}{role} \PYG{n+nx}{\PYGZus{}newrole}\PYG{p}{)}
\end{sphinxVerbatim}

“sur” represents switch user role. This function will not check current user role but will
simply alter {\hyperref[\detokenize{index:identification}]{\sphinxcrossref{identification}}} mapping of input \sphinxstyleemphasis{\_user} address with input \sphinxstyleemphasis{\_newrole}.
Public functions that can switch user roles all depend on this internal function.

\begin{sphinxadmonition}{tip}{Tip:}
This function is the core of function {\hyperref[\detokenize{index:surreceiver}]{\sphinxcrossref{surReceiver}}} and function {\hyperref[\detokenize{index:surprovider}]{\sphinxcrossref{surProvider}}}.
\end{sphinxadmonition}


\section{\_affordableData}
\label{\detokenize{index:affordabledata}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{\PYGZus{}affordableData} \PYG{p}{(}\PYG{n+nx}{address} \PYG{n+nx}{\PYGZus{}wallet}\PYG{p}{,} \PYG{n+nx}{uint256} \PYG{n+nx}{\PYGZus{}price}\PYG{p}{)}
\end{sphinxVerbatim}

This function is used to find data usage limitation for a receiver.

DataToken balance of this receiver and data service pricing of the linked provider are considered.

The output value can be used for data usage countdown.

\begin{sphinxadmonition}{warning}{Warning:}
Current version of contract is not ready for the countdown feature.
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
function {\hyperref[\detokenize{index:link}]{\sphinxcrossref{link}}} depends on this function because it requires receiver must have balance to pay for no less than 1 MB to call function {\hyperref[\detokenize{index:link}]{\sphinxcrossref{link}}}.
\end{sphinxadmonition}


\section{\_tolerance}
\label{\detokenize{index:tolerance}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{\PYGZus{}tolerance} \PYG{p}{(}\PYG{n+nx}{uint256} \PYG{n+nx}{\PYGZus{}range}\PYG{p}{,} \PYG{n+nx}{uint256} \PYG{n+nx}{\PYGZus{}usageLimit}\PYG{p}{)}
\end{sphinxVerbatim}

This function is used from receiver’s perspective. When a receiver is about to quit AP service from the provider,
this function checks mapping {\hyperref[\detokenize{index:usageof}]{\sphinxcrossref{usageOf}}} values of both the receiver and the provider to make sure they agree with each other within a tolerance defined as consensus of this contract.

\begin{sphinxadmonition}{tip}{Tip:}
function {\hyperref[\detokenize{index:payandleave}]{\sphinxcrossref{payAndLeave}}} requires \_tolerance to be true.
\end{sphinxadmonition}


\section{\_cashier}
\label{\detokenize{index:cashier}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{\PYGZus{}cashier} \PYG{p}{(}\PYG{n+nx}{address} \PYG{n+nx}{\PYGZus{}payer}\PYG{p}{,} \PYG{n+nx}{uint256} \PYG{n+nx}{\PYGZus{}volume}\PYG{p}{)}
\end{sphinxVerbatim}

This function is responsible to collecting payment from a receiver when the receiver calls function {\hyperref[\detokenize{index:payandleave}]{\sphinxcrossref{payAndLeave}}}.

\begin{sphinxadmonition}{tip}{Tip:}
This function is an important component in function {\hyperref[\detokenize{index:payandleave}]{\sphinxcrossref{payAndLeave}}}.
\end{sphinxadmonition}


\chapter{Public Functions}
\label{\detokenize{index:public-functions}}
Public functions can be invoked in other contracts and is callable by Web3 Javascript API.


\section{DataTokenAlpha}
\label{\detokenize{index:datatokenalpha}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kd}{function} \PYG{n+nx}{DataTokenAlpha}\PYG{p}{(}\PYG{p}{)} \PYG{k+kr}{public} \PYG{p}{\PYGZob{}}
    \PYG{n+nx}{owner} \PYG{o}{=} \PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{;}
    \PYG{n+nx}{balance}\PYG{p}{[}\PYG{n+nx}{owner}\PYG{p}{]} \PYG{o}{=} \PYG{n+nx}{totalSupply}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
This is the constructor function of solidity contract DataTokenAlpha.
\end{sphinxadmonition}


\section{transfer}
\label{\detokenize{index:id3}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{transfer}\PYG{p}{(}\PYG{n+nx}{address} \PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{n+nx}{uint256} \PYG{n+nx}{\PYGZus{}value}\PYG{p}{)}
\end{sphinxVerbatim}


\section{buyToken}
\label{\detokenize{index:buytoken}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kd}{function} \PYG{n+nx}{buyToken}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nx}{payable}
\PYG{k+kr}{public}
\PYG{n+nx}{returns}\PYG{p}{(}\PYG{n+nx}{bool} \PYG{n+nx}{success}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n+nx}{\PYGZus{}transfer}\PYG{p}{(}\PYG{n+nx}{owner}\PYG{p}{,} \PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{,} \PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{value} \PYG{o}{/} \PYG{l+m+mi}{10} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{k+kc}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This function is payable. That means, any contract user can call this function with a specified Ethereum value in terms of \sphinxhref{http://ethdocs.org/en/latest/ether.html}{wei}.
The function will then transfer equivalent amount of DataToken from \sphinxstyleemphasis{owner} address to the buyer’s address according to
the exchange rule that 1 DataToken = 1,000,000,000 wei = 1 Gwei.

\begin{sphinxadmonition}{warning}{Warning:}
Thi function will only transfer Ether from buyer to contract rather than from buyer to \sphinxstyleemphasis{owner} to buy DataToken. There should be a way for the \sphinxstyleemphasis{owner} to deposit Ether from the contract.
\end{sphinxadmonition}


\section{surProvider}
\label{\detokenize{index:surprovider}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{surProvider} \PYG{p}{(}\PYG{n+nx}{uint256} \PYG{n+nx}{\PYGZus{}price}\PYG{p}{,} \PYG{n+nx}{string} \PYG{n+nx}{\PYGZus{}passwd}\PYG{p}{)}
\end{sphinxVerbatim}

This function can only be called by contract users with {\hyperref[\detokenize{index:identification}]{\sphinxcrossref{identification}}} role.ISRECEIVER.
On success, \sphinxstyleemphasis{role.ISPROVIDER} will be assigned to identification mapping of the message sender.


\section{surReceiver}
\label{\detokenize{index:surreceiver}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{surReceiver} \PYG{p}{(}\PYG{n+nx}{uint} \PYG{n+nx}{\PYGZus{}numberOfUsers}\PYG{p}{)}
\end{sphinxVerbatim}

When a provider want to switch back to be a receiver, this function will be there for help.
The provider will be required to have no linked receiver who is using wireless AP under the name of this provider.
On success, \sphinxstyleemphasis{role.ISRECEIVER} will be assigned to {\hyperref[\detokenize{index:identification}]{\sphinxcrossref{identification}}} mapping of the message sender.


\section{link}
\label{\detokenize{index:link}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{link} \PYG{p}{(}\PYG{n+nx}{address} \PYG{n+nx}{\PYGZus{}provider}\PYG{p}{)}
\end{sphinxVerbatim}

Only receivers with \sphinxstyleemphasis{role.ISRECEIVER} can call this function.
This function will pair the message sender with the designated provider.

..warning:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{This} \PYG{n}{function} \PYG{n}{actually} \PYG{n}{relies} \PYG{n}{on} \PYG{n}{a} \PYG{n}{address} \PYG{n}{resolver} \PYG{n}{since} \PYG{n}{the} \PYG{n}{frontend} \PYG{n}{client} \PYG{n}{should} \PYG{n}{only} \PYG{n}{feed} \PYG{n}{the} \PYG{n}{function} \PYG{n}{APID}\PYG{o}{.} \PYG{n}{And} \PYG{n}{such} \PYG{n}{resolver} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{implemented}\PYG{o}{.}
\end{sphinxVerbatim}


\section{usageRecord}
\label{\detokenize{index:usagerecord}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{usageRecord} \PYG{p}{(}\PYG{n+nx}{address} \PYG{n+nx}{\PYGZus{}theOtherSide}\PYG{p}{,} \PYG{n+nx}{uint256} \PYG{n+nx}{\PYGZus{}usage}\PYG{p}{)}
\end{sphinxVerbatim}

This function assigns value of {\hyperref[\detokenize{index:usageof}]{\sphinxcrossref{usageOf}}} in terms of MB.

\begin{sphinxadmonition}{warning}{Warning:}
There should be some timing and data refreshing features to make the mapped data up to date, however, this feature is not implemented within this version of contract.
\end{sphinxadmonition}


\section{payAndLeave}
\label{\detokenize{index:payandleave}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{payAndLeave} \PYG{p}{(}\PYG{n+nx}{uint256} \PYG{n+nx}{\PYGZus{}range}\PYG{p}{,} \PYG{n+nx}{uint256} \PYG{n+nx}{\PYGZus{}usageLimit}\PYG{p}{)}
\end{sphinxVerbatim}

When a receiver wish to leave it’s wireless AP, it can call this function to issue a payment and disconnect from the provider.



\renewcommand{\indexname}{Index}
\printindex
\end{document}